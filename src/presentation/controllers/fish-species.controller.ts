import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  UseGuards,
} from '@nestjs/common';
import { JwtAuthGuard } from '@presentation/guards/jwt-auth.guard';
import { CurrentUser } from '@presentation/decorators/current-user.decorator';
import { UserDto } from '@application/dtos/auth.dto';
import { ResponseDto } from '@presentation/dto/response.dto';
import { FishSpeciesRepository } from '@infrastructure/repositories/fish-species.repository';
import {
  CreateFishSpeciesDto,
  FishSpeciesDto,
  UpdateFishSpeciesDto,
} from '@application/dtos/fish-species.dto';
import { FishSpecies } from '@domain/entities/fish-species.entity';

@Controller('fish-species')
@UseGuards(JwtAuthGuard) // Protect all routes in this controller
export class FishSpeciesController {
  constructor(private readonly fishSpeciesRepository: FishSpeciesRepository) {}

  @Post()
  async create(
    @Body() createDto: CreateFishSpeciesDto,
    @CurrentUser() user: UserDto,
  ) {
    try {
      // Create entity from DTO
      const fishSpecies = new FishSpecies(
        0, // ID will be auto-generated by database
        createDto.nameEn,
        createDto.nameVn,
        createDto.tempMin,
        createDto.tempMax,
        createDto.phMin,
        createDto.phMax,
        createDto.minTankSize,
        createDto.sizeMax,
        createDto.careLevel,
        createDto.temperament,
        createDto.dietType,
        createDto.description,
        createDto.scientificName,
        createDto.aliases,
        createDto.imageUrl,
        createDto.ghMin,
        createDto.ghMax,
        createDto.bioloadLevel,
        createDto.flowPreference,
        createDto.isSchooling,
        createDto.minSchoolSize,
        createDto.plantSafe,
        createDto.substrateDigger,
        createDto.jumper,
      );

      const saved = await this.fishSpeciesRepository.save(fishSpecies);
      const dto = FishSpeciesDto.fromEntity(saved);

      return ResponseDto.success(dto, 'Fish species created successfully');
    } catch (error) {
      return ResponseDto.error(error.message);
    }
  }

  @Get()
  async findAll(@CurrentUser() user: UserDto) {
    try {
      const fishSpecies = await this.fishSpeciesRepository.findAll();
      const dtos = FishSpeciesDto.fromEntities(fishSpecies);

      return ResponseDto.success(dtos);
    } catch (error) {
      return ResponseDto.error(error.message);
    }
  }

  @Get(':id')
  async findById(
    @Param('id', ParseIntPipe) id: number,
    @CurrentUser() user: UserDto,
  ) {
    try {
      const fishSpecies = await this.fishSpeciesRepository.findById(id);

      if (!fishSpecies) {
        return ResponseDto.error('Fish species not found');
      }

      const dto = FishSpeciesDto.fromEntity(fishSpecies);
      return ResponseDto.success(dto);
    } catch (error) {
      return ResponseDto.error(error.message);
    }
  }

  @Patch(':id')
  async update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateDto: UpdateFishSpeciesDto,
    @CurrentUser() user: UserDto,
  ) {
    try {
      const existing = await this.fishSpeciesRepository.findById(id);

      if (!existing) {
        return ResponseDto.error('Fish species not found');
      }

      // Apply updates to entity using business methods
      if (
        updateDto.nameEn !== undefined ||
        updateDto.nameVn !== undefined ||
        updateDto.scientificName !== undefined ||
        updateDto.imageUrl !== undefined
      ) {
        existing.updateIdentity(
          updateDto.nameEn,
          updateDto.nameVn,
          updateDto.scientificName,
          updateDto.imageUrl,
        );
      }

      if (
        updateDto.tempMin !== undefined ||
        updateDto.tempMax !== undefined ||
        updateDto.phMin !== undefined ||
        updateDto.phMax !== undefined ||
        updateDto.ghMin !== undefined ||
        updateDto.ghMax !== undefined
      ) {
        existing.updateWaterParameters(
          updateDto.tempMin,
          updateDto.tempMax,
          updateDto.phMin,
          updateDto.phMax,
          updateDto.ghMin,
          updateDto.ghMax,
        );
      }

      if (
        updateDto.minTankSize !== undefined ||
        updateDto.sizeMax !== undefined ||
        updateDto.bioloadLevel !== undefined ||
        updateDto.flowPreference !== undefined
      ) {
        existing.updateTankRequirements(
          updateDto.minTankSize,
          updateDto.sizeMax,
          updateDto.bioloadLevel,
          updateDto.flowPreference,
        );
      }

      if (
        updateDto.careLevel !== undefined ||
        updateDto.temperament !== undefined ||
        updateDto.dietType !== undefined ||
        updateDto.isSchooling !== undefined ||
        updateDto.minSchoolSize !== undefined ||
        updateDto.plantSafe !== undefined ||
        updateDto.substrateDigger !== undefined ||
        updateDto.jumper !== undefined
      ) {
        existing.updateBehavior(
          updateDto.careLevel,
          updateDto.temperament,
          updateDto.dietType,
          updateDto.isSchooling,
          updateDto.minSchoolSize,
          updateDto.plantSafe,
          updateDto.substrateDigger,
          updateDto.jumper,
        );
      }

      if (updateDto.description !== undefined) {
        existing.updateDescription(updateDto.description);
      }

      // Handle aliases separately
      if (updateDto.aliases !== undefined) {
        // For simplicity, we'll replace all aliases
        // In a real app, you might want separate addAlias/removeAlias endpoints
        const updated = await this.fishSpeciesRepository.update(id, {
          aliases: updateDto.aliases,
        } as any);
        const dto = FishSpeciesDto.fromEntity(updated);
        return ResponseDto.success(dto, 'Fish species updated successfully');
      }

      const updated = await this.fishSpeciesRepository.update(id, existing);
      const dto = FishSpeciesDto.fromEntity(updated);

      return ResponseDto.success(dto, 'Fish species updated successfully');
    } catch (error) {
      return ResponseDto.error(error.message);
    }
  }

  @Delete(':id')
  async delete(
    @Param('id', ParseIntPipe) id: number,
    @CurrentUser() user: UserDto,
  ) {
    try {
      const existing = await this.fishSpeciesRepository.findById(id);

      if (!existing) {
        return ResponseDto.error('Fish species not found');
      }

      await this.fishSpeciesRepository.delete(id);
      return ResponseDto.success(null, 'Fish species deleted successfully');
    } catch (error) {
      return ResponseDto.error(error.message);
    }
  }
}
